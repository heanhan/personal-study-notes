### Redis的缓存穿透/击穿/雪崩以及数据的一致性的解决方案

无论是开发过程中还是准备跑路的面试过程中，油管redis的相关的面试总会设计到四个特殊的场景;缓存穿透、缓存雪崩、缓存击穿以及数据的一致性问题。

#### 1、缓存穿透

缓存穿透是指查询缓存和数据库都不存在的问题，导致所有的查询压力全部给到数据库。比如查询一篇文章信息并对其缓存，一般的逻辑是先查询缓存中是否存在该文章，如果存在则直接返回，否则再查询数据库并将结果进行缓存。

如果项目访问的并发量不大问题不大，如果项目并发量变大，这样存在一个隐患，如果在访问了一个不存在的文章(这个文章已经被 分享出去，但是在后台可能是被删除了护着下线了)，那么就会导致所有的请求全部需要到数据库中进行查询，从而给数据库造成压力，甚至宕机。

##### 解决方案一：缓存空对象

```
针对缓存穿透的问题环翠空对象可以有效的避免所产生的影响，档查询一条不存在的数据时，在缓存中存储一个空对象并设置过期时间（设置过期时间是为了避免数据库存在了数据但是缓存仍然是空数据的现象），这样可以有效避免所有的请求查询数据库。
```

##### 解决方案二：使用布隆过滤器（重点，目前还不理解）

```
使用布隆过滤器，缓存空对象的缺点在于无论数据存不存在，都需要查询一次数据库，并且redis中存储了大量的空数据。这个时候可以采用布隆过滤器来解决。布隆过滤器恶意简单的理解为一个很长的二进制数据结合的n个hash算法计算出个n个数据下标，并将这些数据下标设置为1，在查找数据时，再次通过n个hash算法计算出数组的下标，如果这个下标的值为1，表示该值可能存在（存在hash冲突的原因），如果为0，则表示该值一定不存在。
```

#### 2、缓存击穿

缓存击穿是指访问某个热点数据时，缓存中并不存在该数据，或者缓存过期了，这个时候全部的请求压力，给到了数据库。

针对缓存击穿的问题，有两种解决方案，一个是热点数据不设置过期时间，另一个是采用互斥锁的方式。

##### 解决方案一：热点数据不设置过期时间

```
热点数据不设置过期时间，当后台更新了热点数据需要同步更新给缓存数据，这样数据使用与不严格要求数据缓存一直性的场景
```

##### 解决方案二：使用互斥锁

```
如果是单机部署的环境下可以使用synchronized或者lock来处理，保证同时只能有一个线程来查询数据库。其他的线程可能等待数据缓存成功后在被唤醒，从而字节查询缓存即可，如果是分布式部署的，可以使用分布式锁来实现互斥锁。

注：了解redis实现互斥锁和 redission实现的分布式式锁。
```

### 3、缓存雪崩

缓存雪崩是指对热点数据设置了相同的过期时间，在同一时间这些热点数据key 大批量发生过期，请求全部转发到数据库，从而导致数据库的压力剧增，甚至宕机。与缓存击穿不同，缓存击穿是耽搁热点数据过期，而缓存雪崩是大批量的热点数据过期。

##### 解决方案一：设置随机的过期时间

```
将key的过期时间后边加上一个随机数，这个随机数的范围可以根据自己的业务情况自行设定，这样可以让key均匀的失效，避免大批量的同时时效。
```

##### 解决方案二：不设置过期时间

```
不设置过期时间，需要注意的是，在更新数据数据时，同时也需要更新缓存数据，否则会出现不一致的情况，这种适合用于不严格要求缓存一致性的场景。
```

##### 解决方案三：搭建高可用的集群

缓存服务器故障时，也会触发雪崩，为了避免因服务器故障而发生的雪崩，推荐使用考科用的服务器集群，这样即使发生故障，也可以进行故障转移，

#### 4、数据一致性问题

先更新数据库，在更新缓存和先更新缓存，在更新数据库的情况基本一致，如果失败会导致数据库中是最新的数据，缓存中的数据是旧数据。还有一种极端情况，在高并发情况下，容易出现数据覆盖的现象：A线程更新完数据库后，在要执行更新缓存的操作时，线程阻塞了，这个时候线程B更新了数据库并成功更新了缓存，当B执行完成后A线程继续向下执行，那么最终线程B的数据会被覆盖。

##### 先删除缓存，再更新数据库

```
先删除缓存，再更新数据库这种情况，如果并发量不大，用起来不会有啥问题，但是在并发场景下，会有这样的问题：线程A在删除缓存后，在写入数据库前发生了阻塞，这样线程B查询了这条数据，发现缓存中不存在，鸡儿向数据库发起了查询请求，并将查询的结果缓存到redis中，当线程B执行完成后，线程A继续向下执行更了数据库，那么这时候缓存中的数据依旧是旧数据，与数据库中的值不一致。
```

##### 新更新数据库，再删除缓存

```
先更新数据库，在删除缓存并非绝对安全，在高并发场景下，如果线程A查询一条在缓存中不存在的数据（这条数据可能过期被删除了），查询数据库后在要讲查询的结果缓存到redis时发生了阻塞，这个时候线程B发出了更新请求，先更新数据库，再次删除了缓存。当线程B执行成功后，线程A继续向下执行，将查询结果缓存到redis中，那么缓存中的数据与数据库发生了不一致。
```

### 解决数据不一致方案：延时双删

```
延时双删，即在写数据库之前删除一次，写完数据库后，再删除一次，在第二次删除时，并不是立即删除，而是等待一定时间在做删除。
```

