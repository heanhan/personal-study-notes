相信大家在实际工作中，或多或少都有接触过并发任务执行的情况，在多线程执行场景中，各个函数的调用通常都是轮流切换的状态，就如同下图所示：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55cd9c87c99d40ccbfffcc248bc68171~tplv-k3u1fbpfcp-zoom-1.image)

A，B，C 三个线程的任务都是交替执行的，也就意味着，任一线程的任务可能会在执行到一半的时候暂停一段时间，然后等下一次执行的时候才恢复过来。

来看看下边这个案例你可能就对多任务执行的逻辑更加清晰了：

```java
public class CpuTaskDemo {

    public void printChar(String word){
        System.out.print(word);
    }

    public static void main(String[] args) {
        CpuTaskDemo c = new CpuTaskDemo();
        Thread taskA = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i=0;i<100;i++){
                    c.printChar("A");
                }
            }
        });
        taskA.start();

        Thread taskB = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i=0;i<100;i++){
                    c.printChar("B");
                }
            }
        });
        taskB.start();

        Thread taskC = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i=0;i<100;i++){
                    c.printChar("C");
                }
            }
        });
        taskC.start();

        Thread taskD = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i=0;i<100;i++){
                    c.printChar("D");
                }
            }
        });
        taskD.start();
    }
}
```
这个案例中，我们通过构建了 4 个线程，分别输出 A，B，C，D 字符，但是通过实际的运行结果却发现，实际打印出来的内容并没有固定的先后顺序：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d53c11bbfd545378ab1c4f5e227dbd5~tplv-k3u1fbpfcp-zoom-1.image)

**为什么B线程会出现执行到一半又暂停，后边又再次执行的情况呢？为什么各个线程的执行任务会同时进行呢？**

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76ad39f297e2457bad0b3b8aecd63c36~tplv-k3u1fbpfcp-zoom-1.image)

**其实这一切都和操作系统的多任务调度机制有关。**

多任务调度的本质，就是**让CPU从就绪线程队列中寻找一个合适的线程/进程，然后将它作为下一个需要执行的任务单元**。那么该如何选择下一个合适的进程/线程呢？这就涉及到了 CPU 的调度机制。

### CPU的调度机制

CPU的调度机制主要划分为两种类型：

-   **抢占式调度：** 交给操作系统的内核来决定中断哪些任务。
-   **非抢占式调度：** 必须要等运行中的任务完全运行结束后，才可以切换为下一个任务，任务在运行过程中不允许被终止。

另外当任务被中断的时候，大多数都是由内核态去操作的，这一系列的行为对于用户态是无感知的。在 Linux 操作系统中，大多数的场景都是采用了抢占式调度。

当然操作系统的多任务调度也不是遇见啥就干啥的，没有任何策略的，它也有自己的评估机制。

CPU 在执行调度决策的时候主要会从以下几个点去衡量：

-   CPU 的整体繁忙状态所占时间比例。
-   整个系统的吞吐量高低。
-   单个任务执行的周期时长。
-   单个任务的等待周期时长。
-   提交请求到响应所花费的整体时长。

通常在 IO 拷贝类型的任务中，更多会关注数据的吞吐量是否足够高，而在一些桌面应用程序中，则会更多关注响应速度是否足够快的要点。

我们工作中所接触到的应用服务器，通常都使用 Linux 操作系统，下边我们就一起了解下 Linux 操作系统中常见的几款调度策略实现机制。

#### 先来先服务算法

这类算法比较简单易懂，假设某一时刻有三个进程同时请求，分别是P1，P2，P3，那么操作系统会按照它们请求的顺序来分配时间片资源，这类算法的底层采用了 FIFO 队列的数据结构，分配结果图如下所示：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d11ae960d31437bbfac3e8dd3c5e0ee~tplv-k3u1fbpfcp-zoom-1.image)

我们可以假设每个任务的执行时间分别为t1，t2，t3，那么整体资源的平均响应时间就为：

```java
avg_time = (t1 + t2 + t3) / 3
```
假设 t1=18ms，t2=10ms，t3=14ms，那么平均时长就是 （18+10+14）/ 3 = 14ms。

**这类算法的优点在于简单易懂，但是对于一些耗时较短的任务而言需要花费更多的时间去等待**，例如下图这种情况。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab0348e32b414a1cbdf133dc57e28d1c~tplv-k3u1fbpfcp-zoom-1.image)

由于按照先来先作业的方式执行任务，那么会导致许多小的任务都被堆积到了队列的末尾去执行，因此整体的平均等待时长就会被升高。

#### 短作业优先算法

刚才我们提到了这种多个小任务连续执行的情况，为了解决这类场景，于是便有人发明了短作业优先的算法。这类算法会按照执行的时间进行排序，将耗时最低的任务先执行，整体执行流程如下图所示：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/426c58d83b3d42f58a62092f563f3cc7~tplv-k3u1fbpfcp-zoom-1.image)

短作业优先算法其实细分的话有两种模式，一种是 srt 直接抢占模式，一种是 spn 非抢占模式，如何理解这两种模式呢，下边我们来看一个例子。

假设当前执行的进程是p3，占用了 4 个时间片，当 p3 还在运行的过程中加入了新的任务 p4，p4 只需要占用 1 个时间片便可执行结束，那么在采用短作业优先算法的情况下，此时 CPU 该立马去执行 p4，还是继续执行 p3 呢？

-   **srt模式**：将 p3 任务挂起，立马执行 p4。
-   **spn模式**：继续执行 p3 任务，将 p4 丢入就绪队列中。

这类算法的核心目的就是尽可能地将任务的执行耗时给降低，但是也会遇到一个比较困难的问题，**如何在任务执行之前预知它所消耗的时长？**

#### 最优平均等待时间算法

这种调度算法的实现复杂度会稍高一些，它主要是基于最短作业优先算法的基础上进行了优化，对于最近一段时间内每个执行过的进程的耗时都会有一个记录，这个记录会作为下一次时间片分配顺序的一个依据，当然这个依据可以进行加权管理。

#### 优先级队列算法

最优平均等待时间算法似乎解决了大部分场景的分配问题，那么为什么还会有优先级队列算法呢？来看下边这么一个场景：
假设某一时刻，突然来了一个优先级非常高的急切任务，此时 CPU 正在执行一些其他程序无法退出，那么这个时候带给用户的体验感就会很差。所以给每个执行的任务都设定一个优先级就会显得格外重要。当遇到紧急任务的时候，优先将时间片分给那些需要时间的线程去执行。

那么，**我们又该如何实现任务的优先级计算呢？**

其实我们可以利用任务的等待时间和预估执行时间，按照一定的函数去做计算后，得出具体的优先级。

下边我给出一种自己的思考方法，假设任务的等待时间为 W，任务的预估执行时间为 E，那么可以参照以下公式进行计算：

```java
P = (W+E)/E
```

按照这段公式最终得出结果如下：

| **任务名称** | **W（任务等待时间）** | **E（任务预估执行时间）** | **P** |
| -------- | ------------- | --------------- | ----- |
| P1       | 1             | 2               | 1.5   |
| P2       | 1             | 3               | 1.33  |
| P3       | 2             | 5               | 1.4   |
| P4       | 1             | 5               | 1.2   |

这里面的任务预估时间 E 数值，可以根据 OS 历史过往执行任务的耗时记录中推测得到，而 W 则是包括了从分配到时间片到开始执行任务过程中的等待耗时。根据计算公式推导得出，上表中各任务的优先级为：P1，P3，P2，P4，接着将它们按照优先级顺序存储在一个“堆”结构中，这样每次执行只需从堆中提取即可。

#### 多级反馈队列算法

这类算法其实是将上述的几种算法都做了一些综合，它将进程任务切分成了多个队列，不同的队列采用不同的调度算法。例如一些优先级别较高的进程可以使用短作业优先算法，低级别一些的进程则使用先来先服务的策略算法。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3f3861d35d7462cbe1b42d9a2f24185~tplv-k3u1fbpfcp-zoom-1.image)

有的任务随着执行时间越久，其任务的等级会上升或下降，例如一些 CPU 计算型任务，计算多的进程对于时间片消耗较高，一般会被放在低级别的队列中，而一些耗时较短的任务可以直接放在高级别的队列中。

面对这么多级别的队列，单个 CPU 在进行时间片划分的时候也会有优先级，通常是按照 level 等级进行划分，例如当 queue1 中处于空闲状态，则会考虑往 queue2 中分配时间片，其他队列也依此类推。

其实如今的操作系统中所采用的算法有非常多的类型，上述的这几种算法只是一类比较经典且具有代表性的算法，感兴趣的朋友可以去自行去深入了解下其他算法的实现思路。

### 课后小结

通过本章节的学习，我们了解了为什么多线程执行过程中会有“间断”的这种现象，其实这是和 CPU 底层的调度算法有关。在文中，我们一同了解了 Linux 操作系统底层的核心调度算法的设计思路，它们主要有以下几类：

-   先来先服务算法；
-   短作业优先算法；
-   最优平均等待时间算法；
-   优先级队列算法；
-   多级反馈队列算法。

通过这几类算法的结合，CPU才实现了多任务调度的机制。

### 课后思考

**上节课答疑**

在上一章节的末尾处我们留下了一道思考题，关于线程的上下文切换过程中会有哪些问题呢？这里我给出自己的一些思考：

**同一个进程中的多线程切换**

1.  发送中断信号通知到内核态线程。
1.  线程停止执行，并且将当前的寄存器信息进行保存。
1.  切换状态准备执行下一个线程任务。
1.  将下一个线程的上下文信息加载到寄存器中。
1.  开始执行下一个线程的任务。

**不同进程中的多线程切换**

这种模式实际上就和多进程切换没有什么差别了，它的开销要比上边提到的同一个进程间多线程切换大好多倍，除开要保存原先进程的寄存器之外，还会触发到 TLB 的刷新操作。

在 CPU 里有一个叫 TLB 的角色 ，它主要用于缓存虚拟内存到物理内存映射关系的页表，如果进程发生上下文切换，会导致该部分缓冲的上一个进程的页表映射关系成为脏页，此时 CPU 会刷新整个 TLB 为新进程的页表，这个过程也是多进程切换中最为消耗性能的环节。

因此现在的大多数应用程序基本都是通过多线程模型的运作方式来提升整体性能，但是在一些大数据领域多进程模式依然是主流。

**本章节思考**

关于并发和并行你是怎么理解的呢，欢迎在评论区中说说你的理解。





