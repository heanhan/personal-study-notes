### 线上CPU飙升的问题排查

#### 问题复现

线上的系统突然运行缓慢，cpu飙升，甚至到100%，接着就各种报警，例如接口超时的报警，

#### 2、问题的排查

不管什么问题，既然cpu飙升，肯定要查一下消耗的cpu线程，然后看看GC。

##### 2.1 核心排查步骤

1. 执行 " top" 命令：查看所有进程占系统cpu的排序，极大可能排第一个的就是咱们的java进程（COMMAND列）,pid那一列就是进程号。
2. 执行 "top -Hp 进程号" ： 查看java进程下的所有线程占用cpu的情况。
3. 执行 "printf "%x\n 10 "命令：后续查看线程堆栈信息展示的都是16进制，为了找到咱们的线程的堆栈信息，咱们需要吧县城好转换成16进制。
4. .执行 “jstack 进程号 | grep 线程ID” 查找某进程下-》线程ID（jstack堆栈信息中的nid）=0xa的线程状态。如果“"VM Thread" os_prio=0 tid=0x00007f871806e000 nid=0xa runnable”，第一个双引号圈起来的就是线程名，如果是“VM Thread”这就是虚拟机GC回收线程了.
5. 执行“jstat -gcutil 进程号 统计间隔毫秒 统计次数（缺省代表一致统计）”，查看某进程GC持续变化情况，如果发现返回中FGC很大且一直增大-》确认Full GC! 也可以使用“jmap -heap 进程ID”查看一下进程的堆内从是不是要溢出了，特别是老年代内从使用情况一般是达到阈值(具体看垃圾回收器和启动时配置的阈值)就会进程Full GC。
6. 执行“jmap -dump:format=b,file=filename 进程ID”，导出某进程下内存heap输出到文件中。

##### 2.2 原因分析

1、内训消耗过大，导致Full GC次数过多，

执行步骤1-5.

- 多个线程的cpu都超多100%，通过jstack 命令可以看到这些线程主要是不是垃圾回收线程
- 通过jstack 命令监控GC情况，可以看到Full GC 次数非常多，并且次数在不断的增加。

确定是Full GC，接下来找到具体原因。

- 生成大量对象，导致内存溢出，

