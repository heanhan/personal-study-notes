### RocketMQ：先写库还是先发消息

**RoketMQ是如何保证消息与数据库的事务一致性？**

#### 两种情况：

##### 1、先写库后发消息：

首先，执行本地数据库事务，出入数据，注意此时还没有commit.紧接着发送消息到MQ,这中间可能由于网络波动等原因，导致生产者迟迟没有收到broker的响应，比如5秒内都没有返回，SendResult给生产者。这也意味着这5秒内本地十五是无法提交的。如果在高并发的场景下，数据库连接资源很快就会被消耗，后续的请求则无法处理，最终系统会崩溃。

##### 2、先发消息后写库

首先他也存在`先写库后发消息`的问题，一旦MQ由于网络等原因长时间没有返回SendResult给生产者，将会导致本地事务无法被提交或回滚，高并发下资源将会被快速耗尽。

其次，生产者将消息发送出去并快速响应了，但是执行本地数据库事务时出现了错误，比如上述代码中的`orderMapper.save(order)`执行出错了，这也就意味着消息已经发送出去，消费者可以消费了，但是此时本地事务失败了，为了弥补错误，此时可能需要“`回滚`”之前发送的消息，但是此时这条消息可能已经被消费了，就算没有被消费，每次我都在发送消息后判断是否出现了异常，如果出现了异常在发送条"`回滚`"的消息，这无疑是增加了开发的复杂度，也显得冗余。

#### RocktMQ的消息事务流程

1、**生产者** 向  **Broker** 发送一条半事务消息，这条半事务消息对消费者是不可见的。

2、**Broker** 向 **Producer** 返回半事务消息发送成功，

3、Producer 发送一条执行本地事务。

4、本地事务comit或者rollback  发送到Broker.

5、如果broker收到的不是commit/rollback，则发起本地回查。

6、回查本地事务状态

7、根据回查的事务状态，决定是commit/rollback

8、commit 后发送消息到 Consumer消费

9、rollback 直接丢弃消息。